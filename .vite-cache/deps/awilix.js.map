{
  "version": 3,
  "sources": ["../../node_modules/awilix/lib/awilix.browser.mjs"],
  "sourcesContent": ["/**\n * Newline.\n */\nconst EOL = '\\n';\n/**\n * An extendable error class.\n * @author https://github.com/bjyoungblood/es6-error/\n */\nclass ExtendableError extends Error {\n    /**\n     * Constructor for the error.\n     *\n     * @param  {String} message\n     * The error message.\n     */\n    constructor(message) {\n        super(message);\n        // extending Error is weird and does not propagate `message`\n        Object.defineProperty(this, 'message', {\n            enumerable: false,\n            value: message,\n        });\n        Object.defineProperty(this, 'name', {\n            enumerable: false,\n            value: this.constructor.name,\n        });\n        // Not all browsers have this function.\n        /* istanbul ignore else */\n        if ('captureStackTrace' in Error) {\n            Error.captureStackTrace(this, this.constructor);\n        }\n        else {\n            Object.defineProperty(this, 'stack', {\n                enumerable: false,\n                value: Error(message).stack,\n                writable: true,\n                configurable: true,\n            });\n        }\n    }\n}\n/**\n * Base error for all Awilix-specific errors.\n */\nclass AwilixError extends ExtendableError {\n}\n/**\n * Error thrown to indicate a type mismatch.\n */\nclass AwilixTypeError extends AwilixError {\n    /**\n     * Constructor, takes the function name, expected and given\n     * type to produce an error.\n     *\n     * @param {string} funcDescription\n     * Name of the function being guarded.\n     *\n     * @param {string} paramName\n     * The parameter there was an issue with.\n     *\n     * @param {string} expectedType\n     * Name of the expected type.\n     *\n     * @param {string} givenType\n     * Name of the given type.\n     */\n    constructor(funcDescription, paramName, expectedType, givenType) {\n        super(`${funcDescription}: expected ${paramName} to be ${expectedType}, but got ${givenType}.`);\n    }\n    /**\n     * Asserts the given condition, throws an error otherwise.\n     *\n     * @param {*} condition\n     * The condition to check\n     *\n     * @param {string} funcDescription\n     * Name of the function being guarded.\n     *\n     * @param {string} paramName\n     * The parameter there was an issue with.\n     *\n     * @param {string} expectedType\n     * Name of the expected type.\n     *\n     * @param {string} givenType\n     * Name of the given type.\n     */\n    static assert(condition, funcDescription, paramName, expectedType, givenType) {\n        if (!condition) {\n            throw new AwilixTypeError(funcDescription, paramName, expectedType, givenType);\n        }\n        return condition;\n    }\n}\n/**\n * A nice error class so we can do an instanceOf check.\n */\nclass AwilixResolutionError extends AwilixError {\n    /**\n     * Constructor, takes the registered modules and unresolved tokens\n     * to create a message.\n     *\n     * @param {string|symbol} name\n     * The name of the module that could not be resolved.\n     *\n     * @param  {string[]} resolutionStack\n     * The current resolution stack\n     */\n    constructor(name, resolutionStack, message) {\n        const stringName = name.toString();\n        const nameStack = resolutionStack.map(({ name: val }) => val.toString());\n        nameStack.push(stringName);\n        const resolutionPathString = nameStack.join(' -> ');\n        let msg = `Could not resolve '${stringName}'.`;\n        if (message) {\n            msg += ` ${message}`;\n        }\n        msg += EOL + EOL;\n        msg += `Resolution path: ${resolutionPathString}`;\n        super(msg);\n    }\n}\n/**\n * A nice error class so we can do an instanceOf check.\n */\nclass AwilixRegistrationError extends AwilixError {\n    /**\n     * Constructor, takes the registered modules and unresolved tokens\n     * to create a message.\n     *\n     * @param {string|symbol} name\n     * The name of the module that could not be registered.\n     */\n    constructor(name, message) {\n        const stringName = name.toString();\n        let msg = `Could not register '${stringName}'.`;\n        if (message) {\n            msg += ` ${message}`;\n        }\n        super(msg);\n    }\n}\n\n/**\n * Resolution modes.\n */\nconst InjectionMode = {\n    /**\n     * The dependencies will be resolved by injecting the cradle proxy.\n     *\n     * @type {String}\n     */\n    PROXY: 'PROXY',\n    /**\n     * The dependencies will be resolved by inspecting parameter names of the function/constructor.\n     *\n     * @type {String}\n     */\n    CLASSIC: 'CLASSIC',\n};\n\n/**\n * Lifetime types.\n */\nconst Lifetime = {\n    /**\n     * The registration will be resolved once and only once.\n     * @type {String}\n     */\n    SINGLETON: 'SINGLETON',\n    /**\n     * The registration will be resolved every time (never cached).\n     * @type {String}\n     */\n    TRANSIENT: 'TRANSIENT',\n    /**\n     * The registration will be resolved once per scope.\n     * @type {String}\n     */\n    SCOPED: 'SCOPED',\n};\n/**\n * Returns true if and only if the first lifetime is strictly longer than the second.\n */\nfunction isLifetimeLonger(a, b) {\n    return ((a === Lifetime.SINGLETON && b !== Lifetime.SINGLETON) ||\n        (a === Lifetime.SCOPED && b === Lifetime.TRANSIENT));\n}\n\n/**\n * Creates a tokenizer for the specified source.\n *\n * @param source\n */\nfunction createTokenizer(source) {\n    const end = source.length;\n    let pos = 0;\n    let type = 'EOF';\n    let value = '';\n    let flags = 0 /* TokenizerFlags.None */;\n    // These are used to greedily skip as much as possible.\n    // Whenever we reach a paren, we increment these.\n    let parenLeft = 0;\n    let parenRight = 0;\n    return {\n        next,\n        done,\n    };\n    /**\n     * Advances the tokenizer and returns the next token.\n     */\n    function next(nextFlags = 0 /* TokenizerFlags.None */) {\n        flags = nextFlags;\n        advance();\n        return createToken();\n    }\n    /**\n     * Advances the tokenizer state.\n     */\n    function advance() {\n        value = '';\n        type = 'EOF';\n        while (true) {\n            if (pos >= end) {\n                return (type = 'EOF');\n            }\n            const ch = source.charAt(pos);\n            // Whitespace is irrelevant\n            if (isWhiteSpace(ch)) {\n                pos++;\n                continue;\n            }\n            switch (ch) {\n                case '(':\n                    pos++;\n                    parenLeft++;\n                    return (type = ch);\n                case ')':\n                    pos++;\n                    parenRight++;\n                    return (type = ch);\n                case '*':\n                    pos++;\n                    return (type = ch);\n                case ',':\n                    pos++;\n                    return (type = ch);\n                case '=':\n                    pos++;\n                    if ((flags & 1 /* TokenizerFlags.Dumb */) === 0) {\n                        // Not in dumb-mode, so attempt to skip.\n                        skipExpression();\n                    }\n                    // We need to know that there's a default value so we can\n                    // skip it if it does not exist when resolving.\n                    return (type = ch);\n                case '/': {\n                    pos++;\n                    const nextCh = source.charAt(pos);\n                    if (nextCh === '/') {\n                        skipUntil((c) => c === '\\n', true);\n                        pos++;\n                    }\n                    if (nextCh === '*') {\n                        skipUntil((c) => {\n                            const closing = source.charAt(pos + 1);\n                            return c === '*' && closing === '/';\n                        }, true);\n                        pos++;\n                    }\n                    break;\n                }\n                default:\n                    // Scans an identifier.\n                    if (isIdentifierStart(ch)) {\n                        scanIdentifier();\n                        return type;\n                    }\n                    // Elegantly skip over tokens we don't care about.\n                    pos++;\n            }\n        }\n    }\n    /**\n     * Scans an identifier, given it's already been proven\n     * we are ready to do so.\n     */\n    function scanIdentifier() {\n        const identStart = source.charAt(pos);\n        const start = ++pos;\n        while (isIdentifierPart(source.charAt(pos))) {\n            pos++;\n        }\n        value = '' + identStart + source.substring(start, pos);\n        type = value === 'function' || value === 'class' ? value : 'ident';\n        if (type !== 'ident') {\n            value = '';\n        }\n        return value;\n    }\n    /**\n     * Skips everything until the next comma or the end of the parameter list.\n     * Checks the parenthesis balance so we correctly skip function calls.\n     */\n    function skipExpression() {\n        skipUntil((ch) => {\n            const isAtRoot = parenLeft === parenRight + 1;\n            if (ch === ',' && isAtRoot) {\n                return true;\n            }\n            if (ch === '(') {\n                parenLeft++;\n                return false;\n            }\n            if (ch === ')') {\n                parenRight++;\n                if (isAtRoot) {\n                    return true;\n                }\n            }\n            return false;\n        });\n    }\n    /**\n     * Skips strings and whitespace until the predicate is true.\n     *\n     * @param callback stops skipping when this returns `true`.\n     * @param dumb if `true`, does not skip whitespace and strings;\n     * it only stops once the callback returns `true`.\n     */\n    function skipUntil(callback, dumb = false) {\n        while (pos < source.length) {\n            const ch = source.charAt(pos);\n            if (callback(ch)) {\n                return;\n            }\n            if (!dumb) {\n                if (isWhiteSpace(ch)) {\n                    pos++;\n                    continue;\n                }\n                if (isStringQuote(ch)) {\n                    skipString();\n                    continue;\n                }\n            }\n            pos++;\n        }\n    }\n    /**\n     * Given the current position is at a string quote, skips the entire string.\n     */\n    function skipString() {\n        const quote = source.charAt(pos);\n        pos++;\n        while (pos < source.length) {\n            const ch = source.charAt(pos);\n            const prev = source.charAt(pos - 1);\n            // Checks if the quote was escaped.\n            if (ch === quote && prev !== '\\\\') {\n                pos++;\n                return;\n            }\n            // Template strings are a bit tougher, we want to skip the interpolated values.\n            if (quote === '`') {\n                const next = source.charAt(pos + 1);\n                if (next === '$') {\n                    const afterDollar = source.charAt(pos + 2);\n                    if (afterDollar === '{') {\n                        // This is the start of an interpolation; skip the ${\n                        pos = pos + 2;\n                        // Skip strings and whitespace until we reach the ending }.\n                        // This includes skipping nested interpolated strings. :D\n                        skipUntil((ch) => ch === '}');\n                    }\n                }\n            }\n            pos++;\n        }\n    }\n    /**\n     * Creates a token from the current state.\n     */\n    function createToken() {\n        if (value) {\n            return { value, type };\n        }\n        return { type };\n    }\n    /**\n     * Determines if we are done parsing.\n     */\n    function done() {\n        return type === 'EOF';\n    }\n}\n/**\n * Determines if the given character is a whitespace character.\n *\n * @param  {string}  ch\n * @return {boolean}\n */\nfunction isWhiteSpace(ch) {\n    switch (ch) {\n        case '\\r':\n        case '\\n':\n        case ' ':\n            return true;\n    }\n    return false;\n}\n/**\n * Determines if the specified character is a string quote.\n * @param  {string}  ch\n * @return {boolean}\n */\nfunction isStringQuote(ch) {\n    switch (ch) {\n        case \"'\":\n        case '\"':\n        case '`':\n            return true;\n    }\n    return false;\n}\n// NOTE: I've added the `.` character, optionally prefixed by `?` so\n// that member expression paths are seen as identifiers.\n// This is so we don't get a constructor token for stuff\n// like `MyClass.prototype?.constructor()`\nconst IDENT_START_EXPR = /^[_$a-zA-Z\\xA0-\\uFFFF]$/;\nconst IDENT_PART_EXPR = /^[?._$a-zA-Z0-9\\xA0-\\uFFFF]$/;\n/**\n * Determines if the character is a valid JS identifier start character.\n */\nfunction isIdentifierStart(ch) {\n    return IDENT_START_EXPR.test(ch);\n}\n/**\n * Determines if the character is a valid JS identifier start character.\n */\nfunction isIdentifierPart(ch) {\n    return IDENT_PART_EXPR.test(ch);\n}\n\n/**\n * Creates a { name: value } object if the input isn't already in that format.\n *\n * @param  {string|object} name\n * Either a string or an object.\n *\n * @param  {*} value\n * The value, only used if name is not an object.\n *\n * @return {object}\n */\nfunction nameValueToObject(name, value) {\n    const obj = name;\n    if (typeof obj === 'string' || typeof obj === 'symbol') {\n        return { [name]: value };\n    }\n    return obj;\n}\n/**\n * Returns the last item in the array.\n *\n * @param  {*[]} arr\n * The array.\n *\n * @return {*}\n * The last element.\n */\nfunction last(arr) {\n    return arr[arr.length - 1];\n}\n/**\n * Determines if the given function is a class.\n *\n * @param  {Function} fn\n * @return {boolean}\n */\nfunction isClass(\n// eslint-disable-next-line @typescript-eslint/no-unsafe-function-type\nfn) {\n    if (typeof fn !== 'function') {\n        return false;\n    }\n    // Should only need 2 tokens.\n    const tokenizer = createTokenizer(fn.toString());\n    const first = tokenizer.next();\n    if (first.type === 'class') {\n        return true;\n    }\n    const second = tokenizer.next();\n    if (first.type === 'function' && second.value) {\n        if (second.value[0] === second.value[0].toUpperCase()) {\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * Determines if the given value is a function.\n *\n * @param  {unknown} val\n * Any value to check if it's a function.\n *\n * @return {boolean}\n * true if the value is a function, false otherwise.\n */\n// eslint-disable-next-line @typescript-eslint/no-unsafe-function-type\nfunction isFunction(val) {\n    return typeof val === 'function';\n}\n/**\n * Returns the unique items in the array.\n *\n * @param {Array<T>}\n * The array to remove dupes from.\n *\n * @return {Array<T>}\n * The deduped array.\n */\nfunction uniq(arr) {\n    return Array.from(new Set(arr));\n}\n\n/*\n * Parses the parameter list of a function string, including ES6 class constructors.\n *\n * @param {string} source\n * The source of a function to extract the parameter list from\n *\n * @return {Array<Parameter> | null}\n * Returns an array of parameters, or `null` if no\n * constructor was found for a class.\n */\nfunction parseParameterList(source) {\n    const { next: _next, done } = createTokenizer(source);\n    const params = [];\n    let t = null;\n    nextToken();\n    while (!done()) {\n        switch (t.type) {\n            case 'class': {\n                const foundConstructor = advanceToConstructor();\n                // If we didn't find a constructor token, then we know that there\n                // are no dependencies in the defined class.\n                if (!foundConstructor) {\n                    return null;\n                }\n                break;\n            }\n            case 'function': {\n                const next = nextToken();\n                if (next.type === 'ident' || next.type === '*') {\n                    // This is the function name or a generator star. Skip it.\n                    nextToken();\n                }\n                break;\n            }\n            case '(':\n                // Start parsing parameter names.\n                parseParams();\n                break;\n            case ')':\n                // We're now out of the parameter list.\n                return params;\n            // When we're encountering an identifier token\n            // at this level, it could be because it's an arrow function\n            // with a single parameter, e.g. `foo => ...`.\n            // This path won't be hit if we've already identified the `(` token.\n            case 'ident': {\n                // Likely a paren-less arrow function\n                // which can have no default args.\n                const param = { name: t.value, optional: false };\n                if (t.value === 'async') {\n                    // Given it's the very first token, we can assume it's an async function,\n                    // so skip the async keyword if the next token is not an equals sign, in which\n                    // case it is a single-arg arrow func.\n                    const next = nextToken();\n                    if (next && next.type !== '=') {\n                        break;\n                    }\n                }\n                params.push(param);\n                return params;\n            }\n            /* istanbul ignore next */\n            default:\n                throw unexpected();\n        }\n    }\n    return params;\n    /**\n     * After having been placed within the parameter list of\n     * a function, parses the parameters.\n     */\n    function parseParams() {\n        // Current token is a left-paren\n        let param = { name: '', optional: false };\n        while (!done()) {\n            nextToken();\n            switch (t.type) {\n                case 'ident':\n                    param.name = t.value;\n                    break;\n                case '=':\n                    param.optional = true;\n                    break;\n                case ',':\n                    params.push(param);\n                    param = { name: '', optional: false };\n                    break;\n                case ')':\n                    if (param.name) {\n                        params.push(param);\n                    }\n                    return;\n                /* istanbul ignore next */\n                default:\n                    throw unexpected();\n            }\n        }\n    }\n    /**\n     * Advances until we reach the constructor identifier followed by\n     * a `(` token.\n     *\n     * @returns `true` if a constructor was found, `false` otherwise.\n     */\n    function advanceToConstructor() {\n        while (!done()) {\n            if (isConstructorToken()) {\n                // Consume the token\n                nextToken(1 /* TokenizerFlags.Dumb */);\n                // If the current token now isn't a `(`, then it wasn't the actual\n                // constructor.\n                if (t.type !== '(') {\n                    continue;\n                }\n                return true;\n            }\n            nextToken(1 /* TokenizerFlags.Dumb */);\n        }\n        return false;\n    }\n    /**\n     * Determines if the current token represents a constructor, and the next token after it is a paren\n     * @return {boolean}\n     */\n    function isConstructorToken() {\n        return t.type === 'ident' && t.value === 'constructor';\n    }\n    /**\n     * Advances the tokenizer and stores the previous token in history\n     */\n    function nextToken(flags = 0 /* TokenizerFlags.None */) {\n        t = _next(flags);\n        return t;\n    }\n    /**\n     * Returns an error describing an unexpected token.\n     */\n    /* istanbul ignore next */\n    function unexpected() {\n        return new SyntaxError(`Parsing parameter list, did not expect ${t.type} token${t.value ? ` (${t.value})` : ''}`);\n    }\n}\n\n// We parse the signature of any `Function`, so we want to allow `Function` types.\n/* eslint-disable @typescript-eslint/no-unsafe-function-type */\n/**\n * RESOLVER symbol can be used by modules loaded by\n * `loadModules` to configure their lifetime, injection mode, etc.\n */\nconst RESOLVER = Symbol('Awilix Resolver Config');\n/**\n * Creates a simple value resolver where the given value will always be resolved. The value is\n * marked as leak-safe since in strict mode, the value will only be resolved when it is not leaking\n * upwards from a child scope to a parent singleton.\n *\n * @param  {string} name The name to register the value as.\n *\n * @param  {*} value The value to resolve.\n *\n * @return {object} The resolver.\n */\nfunction asValue(value) {\n    return {\n        resolve: () => value,\n        isLeakSafe: true,\n    };\n}\n/**\n * Creates a factory resolver, where the given factory function\n * will be invoked with `new` when requested.\n *\n * @param  {string} name\n * The name to register the value as.\n *\n * @param  {Function} fn\n * The function to register.\n *\n * @param {object} opts\n * Additional options for the resolver.\n *\n * @return {object}\n * The resolver.\n */\nfunction asFunction(fn, opts) {\n    if (!isFunction(fn)) {\n        throw new AwilixTypeError('asFunction', 'fn', 'function', fn);\n    }\n    const defaults = {\n        lifetime: Lifetime.TRANSIENT,\n    };\n    opts = makeOptions(defaults, opts, fn[RESOLVER]);\n    const resolve = generateResolve(fn);\n    const result = {\n        resolve,\n        ...opts,\n    };\n    return createDisposableResolver(createBuildResolver(result));\n}\n/**\n * Like a factory resolver, but for classes that require `new`.\n *\n * @param  {string} name\n * The name to register the value as.\n *\n * @param  {Class} Type\n * The function to register.\n *\n * @param {object} opts\n * Additional options for the resolver.\n *\n * @return {object}\n * The resolver.\n */\nfunction asClass(Type, opts) {\n    if (!isFunction(Type)) {\n        throw new AwilixTypeError('asClass', 'Type', 'class', Type);\n    }\n    const defaults = {\n        lifetime: Lifetime.TRANSIENT,\n    };\n    opts = makeOptions(defaults, opts, Type[RESOLVER]);\n    // A function to handle object construction for us, as to make the generateResolve more reusable\n    const newClass = function newClass(...args) {\n        return Reflect.construct(Type, args);\n    };\n    const resolve = generateResolve(newClass, Type);\n    return createDisposableResolver(createBuildResolver({\n        ...opts,\n        resolve,\n    }));\n}\n/**\n * Resolves to the specified registration. Marked as leak-safe since the alias target is what should\n * be checked for lifetime leaks.\n */\nfunction aliasTo(name) {\n    return {\n        resolve(container) {\n            return container.resolve(name);\n        },\n        isLeakSafe: true,\n    };\n}\n/**\n * Given an options object, creates a fluid interface\n * to manage it.\n *\n * @param {*} obj\n * The object to return.\n *\n * @return {object}\n * The interface.\n */\nfunction createBuildResolver(obj) {\n    function setLifetime(value) {\n        return createBuildResolver({\n            ...this,\n            lifetime: value,\n        });\n    }\n    function setInjectionMode(value) {\n        return createBuildResolver({\n            ...this,\n            injectionMode: value,\n        });\n    }\n    function inject(injector) {\n        return createBuildResolver({\n            ...this,\n            injector,\n        });\n    }\n    return updateResolver(obj, {\n        setLifetime,\n        inject,\n        transient: partial(setLifetime, Lifetime.TRANSIENT),\n        scoped: partial(setLifetime, Lifetime.SCOPED),\n        singleton: partial(setLifetime, Lifetime.SINGLETON),\n        setInjectionMode,\n        proxy: partial(setInjectionMode, InjectionMode.PROXY),\n        classic: partial(setInjectionMode, InjectionMode.CLASSIC),\n    });\n}\n/**\n * Given a resolver, returns an object with methods to manage the disposer\n * function.\n * @param obj\n */\nfunction createDisposableResolver(obj) {\n    function disposer(dispose) {\n        return createDisposableResolver({\n            ...this,\n            dispose,\n        });\n    }\n    return updateResolver(obj, {\n        disposer,\n    });\n}\n/**\n * Partially apply arguments to the given function.\n */\nfunction partial(fn, arg1) {\n    return function partiallyApplied() {\n        return fn.call(this, arg1);\n    };\n}\n/**\n * Makes an options object based on defaults.\n *\n * @param  {object} defaults\n * Default options.\n *\n * @param  {...} rest\n * The input to check and possibly assign to the resulting object\n *\n * @return {object}\n */\nfunction makeOptions(defaults, ...rest) {\n    return Object.assign({}, defaults, ...rest);\n}\n/**\n * Creates a new resolver with props merged from both.\n *\n * @param source\n * @param target\n */\nfunction updateResolver(source, target) {\n    const result = {\n        ...source,\n        ...target,\n    };\n    return result;\n}\n/**\n * Returns a wrapped `resolve` function that provides values\n * from the injector and defers to `container.resolve`.\n *\n * @param  {AwilixContainer} container\n * @param  {Object} locals\n * @return {Function}\n */\nfunction wrapWithLocals(container, locals) {\n    return function wrappedResolve(name, resolveOpts) {\n        if (name in locals) {\n            return locals[name];\n        }\n        return container.resolve(name, resolveOpts);\n    };\n}\n/**\n * Returns a new Proxy that checks the result from `injector`\n * for values before delegating to the actual container.\n *\n * @param  {Object} cradle\n * @param  {Function} injector\n * @return {Proxy}\n */\nfunction createInjectorProxy(container, injector) {\n    const locals = injector(container);\n    const allKeys = uniq([\n        ...Reflect.ownKeys(container.cradle),\n        ...Reflect.ownKeys(locals),\n    ]);\n    // TODO: Lots of duplication here from the container proxy.\n    // Need to refactor.\n    const proxy = new Proxy({}, {\n        /**\n         * Resolves the value by first checking the locals, then the container.\n         */\n        get(target, name) {\n            if (name === Symbol.iterator) {\n                return function* iterateRegistrationsAndLocals() {\n                    for (const prop in container.cradle) {\n                        yield prop;\n                    }\n                    for (const prop in locals) {\n                        yield prop;\n                    }\n                };\n            }\n            if (name in locals) {\n                return locals[name];\n            }\n            return container.resolve(name);\n        },\n        /**\n         * Used for `Object.keys`.\n         */\n        ownKeys() {\n            return allKeys;\n        },\n        /**\n         * Used for `Object.keys`.\n         */\n        getOwnPropertyDescriptor(target, key) {\n            if (allKeys.indexOf(key) > -1) {\n                return {\n                    enumerable: true,\n                    configurable: true,\n                };\n            }\n            return undefined;\n        },\n    });\n    return proxy;\n}\n/**\n * Returns a resolve function used to construct the dependency graph\n *\n * @this {Registration}\n * The `this` context is a resolver.\n *\n * @param {Function} fn\n * The function to construct\n *\n * @param {Function} dependencyParseTarget\n * The function to parse for the dependencies of the construction target\n *\n * @param {boolean} isFunction\n * Is the resolution target an actual function or a mask for a constructor?\n *\n * @return {Function}\n * The function used for dependency resolution\n */\nfunction generateResolve(fn, dependencyParseTarget) {\n    // If the function used for dependency parsing is falsy, use the supplied function\n    if (!dependencyParseTarget) {\n        dependencyParseTarget = fn;\n    }\n    // Parse out the dependencies\n    // NOTE: we do this regardless of whether PROXY is used or not,\n    // because if this fails, we want it to fail early (at startup) rather\n    // than at resolution time.\n    const dependencies = parseDependencies(dependencyParseTarget);\n    // Use a regular function instead of an arrow function to facilitate binding to the resolver.\n    return function resolve(container) {\n        // Because the container holds a global reolutionMode we need to determine it in the proper order of precedence:\n        // resolver -> container -> default value\n        const injectionMode = this.injectionMode ||\n            container.options.injectionMode ||\n            InjectionMode.PROXY;\n        if (injectionMode !== InjectionMode.CLASSIC) {\n            // If we have a custom injector, we need to wrap the cradle.\n            const cradle = this.injector\n                ? createInjectorProxy(container, this.injector)\n                : container.cradle;\n            // Return the target injected with the cradle\n            return fn(cradle);\n        }\n        // We have dependencies so we need to resolve them manually\n        if (dependencies.length > 0) {\n            const resolve = this.injector\n                ? wrapWithLocals(container, this.injector(container))\n                : container.resolve;\n            const children = dependencies.map((p) => resolve(p.name, { allowUnregistered: p.optional }));\n            return fn(...children);\n        }\n        return fn();\n    };\n}\n/**\n * Parses the dependencies from the given function.\n * If it's a class that extends another class, and it does\n * not have a defined constructor, attempt to parse it's super constructor.\n */\nfunction parseDependencies(fn) {\n    const result = parseParameterList(fn.toString());\n    if (!result) {\n        // No defined constructor for a class, check if there is a parent\n        // we can parse.\n        const parent = Object.getPrototypeOf(fn);\n        if (typeof parent === 'function' && parent !== Function.prototype) {\n            // Try to parse the parent\n            return parseDependencies(parent);\n        }\n        return [];\n    }\n    return result;\n}\n\n/**\n * Family tree symbol.\n */\nconst FAMILY_TREE = Symbol('familyTree');\n/**\n * Roll Up Registrations symbol.\n */\nconst ROLL_UP_REGISTRATIONS = Symbol('rollUpRegistrations');\n/**\n * The string representation when calling toString.\n */\nconst CRADLE_STRING_TAG = 'AwilixContainerCradle';\n/**\n * Creates an Awilix container instance.\n *\n * @param {Function} options.require The require function to use. Defaults to require.\n *\n * @param {string} options.injectionMode The mode used by the container to resolve dependencies.\n * Defaults to 'Proxy'.\n *\n * @param {boolean} options.strict True if the container should run in strict mode with additional\n * validation for resolver configuration correctness. Defaults to false.\n *\n * @return {AwilixContainer<T>} The container.\n */\nfunction createContainer(options = {}) {\n    return createContainerInternal(options);\n}\nfunction createContainerInternal(options, parentContainer, parentResolutionStack) {\n    options = {\n        injectionMode: InjectionMode.PROXY,\n        strict: false,\n        ...options,\n    };\n    /**\n     * Tracks the names and lifetimes of the modules being resolved. Used to detect circular\n     * dependencies and, in strict mode, lifetime leakage issues.\n     */\n    const resolutionStack = parentResolutionStack ?? [];\n    // Internal registration store for this container.\n    const registrations = {};\n    /**\n     * The `Proxy` that is passed to functions so they can resolve their dependencies without\n     * knowing where they come from. I call it the \"cradle\" because\n     * it is where registered things come to life at resolution-time.\n     */\n    const cradle = new Proxy({\n    /* removed in browser build */\n    }, {\n        /**\n         * The `get` handler is invoked whenever a get-call for `container.cradle.*` is made.\n         *\n         * @param  {object} _target\n         * The proxy target. Irrelevant.\n         *\n         * @param  {string} name\n         * The property name.\n         *\n         * @return {*}\n         * Whatever the resolve call returns.\n         */\n        get: (_target, name) => resolve(name),\n        /**\n         * Setting things on the cradle throws an error.\n         *\n         * @param  {object} target\n         * @param  {string} name\n         */\n        set: (_target, name) => {\n            throw new Error(`Attempted setting property \"${name}\" on container cradle - this is not allowed.`);\n        },\n        /**\n         * Used for `Object.keys`.\n         */\n        ownKeys() {\n            return Array.from(cradle);\n        },\n        /**\n         * Used for `Object.keys`.\n         */\n        getOwnPropertyDescriptor(target, key) {\n            const regs = rollUpRegistrations();\n            if (Object.getOwnPropertyDescriptor(regs, key)) {\n                return {\n                    enumerable: true,\n                    configurable: true,\n                };\n            }\n            return undefined;\n        },\n    });\n    // The container being exposed.\n    const container = {\n        options,\n        cradle,\n        inspect,\n        cache: new Map(),\n        loadModules: () => { throw new Error(\"loadModules is not supported in the browser.\"); },\n        createScope,\n        register: register,\n        build,\n        resolve,\n        hasRegistration,\n        dispose,\n        getRegistration,\n        /* removed in browser build */\n        [ROLL_UP_REGISTRATIONS]: rollUpRegistrations,\n        get registrations() {\n            return rollUpRegistrations();\n        },\n    };\n    // Track the family tree.\n    const familyTree = parentContainer\n        ? [container].concat(parentContainer[FAMILY_TREE])\n        : [container];\n    container[FAMILY_TREE] = familyTree;\n    // We need a reference to the root container,\n    // so we can retrieve and store singletons.\n    const rootContainer = last(familyTree);\n    return container;\n    /**\n     * Used by util.inspect (which is used by console.log).\n     */\n    function inspect() {\n        return `[AwilixContainer (${parentContainer ? 'scoped, ' : ''}registrations: ${Object.keys(container.registrations).length})]`;\n    }\n    /**\n     * Rolls up registrations from the family tree.\n     *\n     * This can get pretty expensive. Only used when\n     * iterating the cradle proxy, which is not something\n     * that should be done in day-to-day use, mostly for debugging.\n     *\n     * @param {boolean} bustCache\n     * Forces a recomputation.\n     *\n     * @return {object}\n     * The merged registrations object.\n     */\n    function rollUpRegistrations() {\n        return {\n            ...(parentContainer && parentContainer[ROLL_UP_REGISTRATIONS]()),\n            ...registrations,\n        };\n    }\n    /**\n     * Used for providing an iterator to the cradle.\n     */\n    function* cradleIterator() {\n        const registrations = rollUpRegistrations();\n        for (const registrationName in registrations) {\n            yield registrationName;\n        }\n    }\n    /**\n     * Creates a scoped container.\n     *\n     * @return {object}\n     * The scoped container.\n     */\n    function createScope() {\n        return createContainerInternal(options, container, resolutionStack);\n    }\n    /**\n     * Adds a registration for a resolver.\n     */\n    function register(arg1, arg2) {\n        const obj = nameValueToObject(arg1, arg2);\n        const keys = [...Object.keys(obj), ...Object.getOwnPropertySymbols(obj)];\n        for (const key of keys) {\n            const resolver = obj[key];\n            // If strict mode is enabled, check to ensure we are not registering a singleton on a non-root\n            // container.\n            if (options.strict && resolver.lifetime === Lifetime.SINGLETON) {\n                if (parentContainer) {\n                    throw new AwilixRegistrationError(key, 'Cannot register a singleton on a scoped container.');\n                }\n            }\n            registrations[key] = resolver;\n        }\n        return container;\n    }\n    /**\n     * Returned to `util.inspect` and Symbol.toStringTag when attempting to resolve\n     * a custom inspector function on the cradle.\n     */\n    function toStringRepresentationFn() {\n        return Object.prototype.toString.call(cradle);\n    }\n    /**\n     * Recursively gets a registration by name if it exists in the\n     * current container or any of its' parents.\n     *\n     * @param name {string | symbol} The registration name.\n     */\n    function getRegistration(name) {\n        const resolver = registrations[name];\n        if (resolver) {\n            return resolver;\n        }\n        if (parentContainer) {\n            return parentContainer.getRegistration(name);\n        }\n        return null;\n    }\n    /**\n     * Resolves the registration with the given name.\n     *\n     * @param {string | symbol} name\n     * The name of the registration to resolve.\n     *\n     * @param {ResolveOptions} resolveOpts\n     * The resolve options.\n     *\n     * @return {any}\n     * Whatever was resolved.\n     */\n    function resolve(name, resolveOpts) {\n        resolveOpts = resolveOpts || {};\n        try {\n            // Grab the registration by name.\n            const resolver = getRegistration(name);\n            if (resolutionStack.some(({ name: parentName }) => parentName === name)) {\n                throw new AwilixResolutionError(name, resolutionStack, 'Cyclic dependencies detected.');\n            }\n            // Used in JSON.stringify.\n            if (name === 'toJSON') {\n                return toStringRepresentationFn;\n            }\n            // Used in console.log.\n            if (name === 'constructor') {\n                return createContainer;\n            }\n            if (!resolver) {\n                // Checks for some edge cases.\n                switch (name) {\n                    // The following checks ensure that console.log on the cradle does not\n                    // throw an error (issue #7).\n                    case 'inspect':\n                    case 'toString':\n                        return toStringRepresentationFn;\n                    case Symbol.toStringTag:\n                        return CRADLE_STRING_TAG;\n                    // Edge case: Promise unwrapping will look for a \"then\" property and attempt to call it.\n                    // Return undefined so that we won't cause a resolution error. (issue #109)\n                    case 'then':\n                        return undefined;\n                    // When using `Array.from` or spreading the cradle, this will\n                    // return the registration names.\n                    case Symbol.iterator:\n                        return cradleIterator;\n                }\n                if (resolveOpts.allowUnregistered) {\n                    return undefined;\n                }\n                throw new AwilixResolutionError(name, resolutionStack);\n            }\n            const lifetime = resolver.lifetime || Lifetime.TRANSIENT;\n            // if we are running in strict mode, this resolver is not explicitly marked leak-safe, and any\n            // of the parents have a shorter lifetime than the one requested, throw an error.\n            if (options.strict && !resolver.isLeakSafe) {\n                const maybeLongerLifetimeParentIndex = resolutionStack.findIndex(({ lifetime: parentLifetime }) => isLifetimeLonger(parentLifetime, lifetime));\n                if (maybeLongerLifetimeParentIndex > -1) {\n                    throw new AwilixResolutionError(name, resolutionStack, `Dependency '${name.toString()}' has a shorter lifetime than its ancestor: '${resolutionStack[maybeLongerLifetimeParentIndex].name.toString()}'`);\n                }\n            }\n            // Pushes the currently-resolving module information onto the stack\n            resolutionStack.push({ name, lifetime });\n            // Do the thing\n            let cached;\n            let resolved;\n            switch (lifetime) {\n                case Lifetime.TRANSIENT:\n                    // Transient lifetime means resolve every time.\n                    resolved = resolver.resolve(container);\n                    break;\n                case Lifetime.SINGLETON:\n                    // Singleton lifetime means cache at all times, regardless of scope.\n                    cached = rootContainer.cache.get(name);\n                    if (!cached) {\n                        // if we are running in strict mode, perform singleton resolution using the root\n                        // container only.\n                        resolved = resolver.resolve(options.strict ? rootContainer : container);\n                        rootContainer.cache.set(name, { resolver, value: resolved });\n                    }\n                    else {\n                        resolved = cached.value;\n                    }\n                    break;\n                case Lifetime.SCOPED:\n                    // Scoped lifetime means that the container\n                    // that resolves the registration also caches it.\n                    // If this container cache does not have it,\n                    // resolve and cache it rather than using the parent\n                    // container's cache.\n                    cached = container.cache.get(name);\n                    if (cached !== undefined) {\n                        // We found one!\n                        resolved = cached.value;\n                        break;\n                    }\n                    // If we still have not found one, we need to resolve and cache it.\n                    resolved = resolver.resolve(container);\n                    container.cache.set(name, { resolver, value: resolved });\n                    break;\n                default:\n                    throw new AwilixResolutionError(name, resolutionStack, `Unknown lifetime \"${resolver.lifetime}\"`);\n            }\n            // Pop it from the stack again, ready for the next resolution\n            resolutionStack.pop();\n            return resolved;\n        }\n        catch (err) {\n            // When we get an error we need to reset the stack. Mutate the existing array rather than\n            // updating the reference to ensure all parent containers' stacks are also updated.\n            resolutionStack.length = 0;\n            throw err;\n        }\n    }\n    /**\n     * Checks if the registration with the given name exists.\n     *\n     * @param {string | symbol} name\n     * The name of the registration to resolve.\n     *\n     * @return {boolean}\n     * Whether or not the registration exists.\n     */\n    function hasRegistration(name) {\n        return !!getRegistration(name);\n    }\n    /**\n     * Given a registration, class or function, builds it up and returns it.\n     * Does not cache it, this means that any lifetime configured in case of passing\n     * a registration will not be used.\n     *\n     * @param {Resolver|Constructor|Function} targetOrResolver\n     * @param {ResolverOptions} opts\n     */\n    function build(targetOrResolver, opts) {\n        if (targetOrResolver && targetOrResolver.resolve) {\n            return targetOrResolver.resolve(container);\n        }\n        const funcName = 'build';\n        const paramName = 'targetOrResolver';\n        AwilixTypeError.assert(targetOrResolver, funcName, paramName, 'a registration, function or class', targetOrResolver);\n        AwilixTypeError.assert(typeof targetOrResolver === 'function', funcName, paramName, 'a function or class', targetOrResolver);\n        const resolver = isClass(targetOrResolver)\n            ? asClass(targetOrResolver, opts)\n            : asFunction(targetOrResolver, opts);\n        return resolver.resolve(container);\n    }\n    /**\n     * Disposes this container and it's children, calling the disposer\n     * on all disposable registrations and clearing the cache.\n     */\n    function dispose() {\n        const entries = Array.from(container.cache.entries());\n        container.cache.clear();\n        return Promise.all(entries.map(([, entry]) => {\n            const { resolver, value } = entry;\n            const disposable = resolver;\n            if (disposable.dispose) {\n                return Promise.resolve().then(() => disposable.dispose(value));\n            }\n            return Promise.resolve();\n        })).then(() => undefined);\n    }\n}\n\nexport { AwilixError, AwilixRegistrationError, AwilixResolutionError, AwilixTypeError, InjectionMode, Lifetime, RESOLVER, aliasTo, asClass, asFunction, asValue, createBuildResolver, createContainer, createDisposableResolver, isClass, isFunction };\n"],
  "mappings": "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",
  "names": ["next", "ch", "newClass", "resolve", "registrations"]
}
